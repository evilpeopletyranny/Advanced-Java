# Stream API

**Stream API** — это одно из ключевых нововведений в Java 8, которое предоставляет мощный инструмент для работы с
коллекциями и другими источниками данных в функциональном стиле. Stream API позволяет выполнять различные операции над
последовательностями элементов, такие как фильтрация, преобразование, агрегирование и другие, используя декларативный
подход.

**Stream** в контексте Java — это некая абстракция, представляющая последовательность элементов, над которыми можно
выполнять вычисления. Потоки (```Streams```) не хранят данные; они предоставляют способ описать вычисления над данными,
которые могут быть выполнены лениво и при необходимости в параллельном режиме.

#### Ключевые особенности Stream API:

- **Декларативный стиль программирования**: описывает что нужно сделать с данными, а не как это сделать.
- **Ленивые вычисления**: промежуточные операции не выполняются до тех пор, пока не вызвана терминальная операция.
- **Поддержка параллельной обработки**: облегчает написание параллельных программ.

# Утройство Stream API

Stream API состоит из следующих основных компонентов:

#### 3.1. Источники потоков

Потоки могут быть созданы из различных источников:

- **Коллекции** (```Collection```): ```collection.stream()```, ```collection.parallelStream()```.
- **Массивы**: ```Arrays.stream(array)```.
- **Потоки данных** (```java.io.InputStream```): преобразование в поток байтов.
- **Генераторы и итераторы**: ```Stream.generate()```, ```Stream.iterate()```.
- **Файлы**: ```Files.lines(path)``` для чтения строк из файла.

#### 3.2. Операции над потоками

Операции над потоками делятся на два типа:

- **Промежуточные операции** (Intermediate Operations):
    - Возвращают новый поток.
    - Выполняются лениво.
    - Примеры: ```filter```, ```map```, ```sorted```, ```distinct```, ```limit```, ```skip```.

- **Терминальные операции** (Terminal Operations):
    - Завершают поток и возвращают результат.
    -
  Примеры: ```forEach```, ```collect```, ```reduce```, ```count```, ```anyMatch```, ```allMatch```, ```noneMatch```, ```findFirst```, ```findAny```.

### Пример

```
List<String> names = Arrays.asList("Анна", "Борис", "Виктор", "Алексей");

List<String> filteredNames = names.stream()
    .filter(name -> name.startsWith("А"))
    .map(String::toUpperCase)
    .sorted()
    .collect(Collectors.toList());

System.out.println(filteredNames); // Вывод: [АЛЕКСЕЙ, АННА]
```

- ```stream()```: создает поток из списка names.
- ```filter```: отбирает имена, начинающиеся с буквы "А".
- ```map```: преобразует имена в верхний регистр.
- ```sorted```: сортирует имена.
- ```collect```: собирает результаты в список.

# Stream API как часть ФП в Java

Stream API тесно связан с концепциями функционального программирования, которое основывается на использовании функций
как объектов первого класса и работе с неизменяемыми данными.

#### Связующие элементы:

- **Лямбда-выражения**: позволяют передавать поведение (функции) в методы.
- **Функции высшего порядка**: методы, принимающие функции в качестве аргументов или возвращающие их.
- **Неизменяемость**: операции над потоками не изменяют исходные данные.
- **Декларативный подход**: описывает желаемый результат без указания алгоритма.

# Роль функциональных интерфейсов в Stream API

Функциональные интерфейсы — это интерфейсы с единственным абстрактным методом. Они являются основой для лямбда-выражений
и используются в Stream API для передачи функций в методы.

#### Примеры функциональных интерфейсов в Stream API:

- ```Predicate<T>```: принимает объект типа ```T``` и возвращает ```boolean```. Используется
  в ```filter```, ```allMatch```, ```anyMatch```, ```noneMatch```.

```
stream.filter(n -> n > 0); // n > 0 — это Predicate<Integer>
```

- ```Function<T, R>```: принимает объект типа ```T``` и возвращает объект типа ```R```. Используется
  в ```map```, ```flatMap```.

```
stream.map(s -> s.length()); // s.length() — это Function<String, Integer>
```

- ```Consumer<T>```: принимает объект типа ```T```, не возвращает результат. Используется в ```forEach```.

```
stream.forEach(System.out::println); // System.out::println — это Consumer<T>
```

- ```Supplier<T>```: не принимает аргументов, возвращает объект типа ```T```. Используется в ```Stream.generate```.

```
Stream.generate(() -> Math.random()); // () -> Math.random() — это Supplier<Double>
```

- **_И тд._**

Использование функциональных интерфейсов позволяет передавать поведение (логику) в методы Stream API, делая код более
гибким и модульным.

# Практические примеры использования Stream API

---

#### Фильтрация и преобразование списка

```
List<String> names = Arrays.asList("Анна", "Борис", "Виктор", "Алексей");

List<String> filteredNames = names.stream()
    .filter(name -> name.startsWith("А"))
    .map(String::toUpperCase)
    .collect(Collectors.toList());

System.out.println(filteredNames); // [АННА, АЛЕКСЕЙ]
```

---

#### Суммирование чисел

```
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

int sum = numbers.stream()
    .reduce(0, Integer::sum);

System.out.println("Сумма: " + sum); // Сумма: 15
```

---

#### Группировка элементов

```
List<String> words = Arrays.asList("apple", "banana", "apricot", "cherry", "avocado");

Map<Character, List<String>> grouped = words.stream()
    .collect(Collectors.groupingBy(word -> word.charAt(0)));

System.out.println(grouped);
// {a=[apple, apricot, avocado], b=[banana], c=[cherry]}
```

---

#### Поиск максимального значения

```
List<Integer> numbers = Arrays.asList(10, 20, 30, 40, 50);

Optional<Integer> max = numbers.stream()
    .max(Integer::compareTo);

max.ifPresent(value -> System.out.println("Максимум: " + value)); // Максимум: 50
```

# Плюсы Stream API

#### Декларативный и лаконичный код

- **Упрощение кода**: уменьшение объема шаблонного кода (boilerplate).
- **Читаемость**: код становится более понятным, так как описывает что нужно сделать.

#### Ленивые вычисления

- **Производительность**: промежуточные операции не выполняются до тех пор, пока не вызвана терминальная операция. Это
  позволяет оптимизировать выполнение, избегая ненужных вычислений.

#### Легкая параллелизация

- **Параллельные потоки**: простое переключение на параллельное выполнение с помощью ```parallelStream()```.
- **Улучшение производительности** на многопроцессорных системах без необходимости управлять потоками вручную.

```
list.parallelStream()
    .filter(...)
    .map(...)
    .collect(...);
```

#### Мощный набор операций

- **Богатый API**: множество встроенных методов для различных операций над данными (фильтрация, преобразование,
  сортировка, агрегация и т.д.).

#### Поддержка функционального программирования

- **Лямбда-выражения** и **функциональные интерфейсы** позволяют писать код в функциональном стиле, что может привести к
  более чистому и модульному коду.

# Минусы Stream API

#### Крутая кривая обучения

- **Новый подход**: разработчики, привыкшие к императивному стилю, могут столкнуться с трудностями при переходе на
  функциональный стиль.

#### Сложность отладки

- **Отладка**: сложные цепочки операций могут быть трудными для отладки, так как лямбда-выражения не имеют имени, а стек
  вызовов может быть менее информативным.

#### Производительность в некоторых случаях

- **Накладные расходы**: создание дополнительных объектов и использование лямбда-выражений может привести к
  дополнительным накладным расходам.
- **Параллельные потоки**: не всегда улучшают производительность и могут привести к ухудшению, особенно при неправильном
  использовании или при работе с небольшими объемами данных.

#### Ограничения в изменении состояния

- **Неизменяемость**: Stream API ориентирован на работу с неизменяемыми данными. Изменение внешнего состояния внутри
  лямбда-выражений может привести к непредсказуемым результатам.

#### Сложность при комбинировании операций

- **Чрезмерно сложные цепочки**: использование большого количества промежуточных операций может сделать код менее
  читаемым.

# Советы по использованию Stream API

- **Избегайте изменения внешнего состояния** внутри лямбда-выражений. Это может привести к непредсказуемому поведению.
- **Делайте цепочки операций не слишком длинными**, чтобы сохранить читаемость кода.
- **Используйте параллельные потоки осторожно**. Параллельная обработка может не всегда быть эффективной и может
  привести к дополнительным накладным расходам.
- **Изучайте стандартные методы** в ```Collectors``` и других классах, чтобы максимально использовать возможности Stream
  API.
- **Профилируйте производительность**. Если производительность критична, убедитесь, что использование Stream API
  действительно улучшает ситуацию.

# Заключение

Stream API — мощный инструмент, который привносит функциональный стиль программирования в Java. Он позволяет писать
более лаконичный и выразительный код для работы с коллекциями и другими источниками данных. Однако важно понимать, как
он работает, и быть внимательным к потенциальным проблемам с производительностью и отладкой.
