# Хэш-функции

**Хэш-функция** — это функция, которая принимает на вход данные произвольного размера и возвращает фиксированное
значение — хэш (также называемый хэш-код, хэш-значение). Хэш служит кратким представлением исходных данных и
используется для быстрого сравнения, поиска и проверки целостности данных.

## Для чего нужна хэш-функция?

Хэш-функции используются в различных областях программирования и компьютерных наук:

1. **Структуры данных**: В таких структурах данных, как хэш-таблицы (```HashMap```, ```HashSet``` в Java), хэш-функции
   используются для быстрого доступа к данным. Они преобразуют ключ в индекс массива, что позволяет выполнять операции
   вставки, удаления и поиска за среднее время ```O(1)```.
2. **Контроль целостности данных**: Хэш-функции позволяют проверять, были ли данные изменены или повреждены, сравнивая
   хэш-значения исходных и полученных данных.
3. **Индексирование и поиск**: В алгоритмах поиска и индексирования хэш-функции помогают эффективно организовать и
   искать данные.
4. **Криптография**: Криптографические хэш-функции используются для обеспечения безопасности данных, включая хранение
   паролей, цифровые подписи и аутентификацию сообщений.

## Виды хэш-функций

Хэш-функции можно разделить на несколько категорий в зависимости от их свойств и областей применения:

### 1. Некриптографические хэш-функции

- **Используются в структурах данных** для быстрого доступа к данным.
- Не предназначены для обеспечения безопасности.

**Пример**: ```hashCode()```

### 2. Криптографические хэш-функции

- Обеспечивают безопасность и обладают свойствами, необходимыми для криптографических приложений.
- Имеют сильные требования к стойкости против коллизий и необратимости.

**Примеры**: ```MD5```, ```SHA-1```, ```SHA-256```, ```SHA-3```.

### 3. Универсальные хэш-функции

- Используются в алгоритмах, где требуется случайность, например, в алгоритмах рандомизированного хэширования.

## Различия между хэш-функцией в Java и криптографической хэш-функцией

### Хэш-функции в Java

- **Назначение**: В Java хэш-функции, такие как метод ```hashCode()```, используются в основном для структур данных,
  например, ```HashMap```, ```HashSet```, ```Hashtable```.
- **Свойства**:
    - **Быстродействие**: Должны быть быстрыми для вычисления.
    - **Распределение**: Стремятся равномерно распределять значения для уменьшения коллизий
    - **Коллизии**: Возможны, но структуры данных справляются с ними с помощью методов разрешения коллизий.
- **Не предназначены для безопасности**: Не должны использоваться для криптографических целей или хранения паролей.

### Криптографические хэш-функции

- **Назначение**: Используются в области безопасности для шифрования, проверки целостности данных, аутентификации.
- **Свойства**:
    - **Необратимость**: Невозможно восстановить исходные данные по хэш-значению.
    - **Стойкость к коллизиям**: Трудно найти два разных входа, дающих одинаковый хэш.
    - **Свойство лавины**: Небольшое изменение во входных данных приводит к значительному изменению хэш-значения.
- **Используются для безопасности**: Подходят для хранения паролей (с солью и функциями растяжения ключа), цифровых
  подписей, контрольных сумм.

## Как работает Хэш-функция в Java

### Для притивов и String

Насколько мы помним примитивы не являеются классами, следовательно для них функции **hashCode()**. Для
притивов ```hashCode()``` вычисляется при помощи классов оберток.

#### Классы-оболочки для примитивов

**Классы-оболочки** (```Integer```, ```Double```, ```Boolean``` и другие) переопределяют метод ```hashCode()```, чтобы
он зависел от значения объекта, а не от его адреса в памяти.

##### Integer.hashCode()

Возвращает само целочисленное значение.

```
Integer a = Integer.valueOf(100);
Integer b = Integer.valueOf(100);

System.out.println(a.hashCode()); // Выведет: 100
System.out.println(b.hashCode()); // Выведет: 100
```

Хотя ```a``` и ```b``` могут быть разными объектами в памяти, их хэш-коды одинаковы, потому что они представляют одно и
то же значение.

##### Boolean.hashCode()

Возвращает ```1231``` для ```true``` и ```1237``` для ```false```.

##### Double.hashCode()

Возвращает хэш-код, вычисленный на основе побитового представления значения double.

#### String.hashCode()

Класс ```String``` переопределяет ```hashCode()```, чтобы он зависел от содержимого строки.

```
String s1 = new String("Привет");
String s2 = new String("Привет");

System.out.println(s1.hashCode()); // Выведет одинаковый хэш-код для s1 и s2
System.out.println(s2.hashCode()); // Хэш-код совпадает с s1

```

Для вычисления ```hashCode()``` для ```String``` используется формула, которая умножает последовательно каждый символ на
простое число в степени ```n-индекс```.

Работает оно потому что в строка храняться символы - ```char```, которые в свою очередь имеют численный код связанный с
кодировкой.

### Для коллекций

Хэш-код коллекции обычно вычисляется на основе хэш-кодов ее элементов. Таким образом, две коллекции с одинаковыми
элементами в одном и том же порядке будут иметь одинаковые хэш-коды.

```
List<Integer> list1 = new ArrayList<>(List.of(1, 2, 3));
List<Integer> list2 = new ArrayList<>(List.of(1, 2, 3));

System.out.println(list1.hashCode()); // Выведет одинаковый хэш-код для list1 и list2
System.out.println(list2.hashCode()); // Хэш-код совпадает с list1
```

### Класс Object и метод по умолчанию ```hashCode()```

По умолчанию, метод ```hashCode()```, определенный в классе ```Object```, возвращает некоторый целочисленный
идентификатор объекта.

Согласно документации, метод ```hashCode()``` по умолчанию может использовать адрес объекта в памяти для вычисления
хэш-кода, но это не гарантируется и зависит от реализации JVM.

### ```hashCode()``` в собственных классах

Пример переопределения ```hashCode()``` для класса ```Person``` с полями ```name``` и ```age```.

```java
import java.util.Objects;

public class Person {
    private String name;
    private int age;

    // Конструктор
    public Person(String name, int age) {
        this.name = Objects.requireNonNull(name, "Name cannot be null");
        this.age = age;
    }

    // Геттеры
    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    // Переопределение equals()
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (Objects.isNull(obj) || getClass() != obj.getClass()) {
            return false;
        }
        Person person = (Person) obj;
        return age == person.age && Objects.equals(name, person.name);
    }

    // Переопределение hashCode()
    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
```

Используем метод ```Objects.hash()```, который возвращает хэш-код на основе указанных полей. Этот метод учитывает
возможность ```null``` значений и упрощает реализацию ```hashCode()```.

#### Ещё раз о ```hashCode()``` в собственном классе...

При реализации метода ```hashCode()``` в своем классе не надо ломать голову, а достаточно воспользоваться уже имеющимися
методами в Java. Все сложные объекты и коллекции в конечном итоге разбиваются на примитивы для которых уже определен
наибыстрый и оптимальный способ вычисления хэша. Нам же остается правильно доопределить метод ```hashCode()``` во всей
матрешке сложного объекта при помощи вызова ```Objects.hashCode()``` к полям класса.

### Итого

```hashCode()``` в Java создавался не для криптографии, а для повышения производительности и работы с коллекциями. Как
вы увидели алгоритмы высчитывания очень простые и не являются криптостойкими.

### Сравнение хэш-функций в Java и криптографических хэш-функций

| Свойство                  | Хэш-функции в Java (`hashCode()`)    | Криптографические хэш-функции       |
|---------------------------|--------------------------------------|-------------------------------------|
| **Назначение**            | Структуры данных (`HashMap`, `HashSet`) | Безопасность, шифрование            |
| **Быстродействие**        | Очень быстрое                        | Относительно медленнее              |
| **Коллизии**              | Допускаются, разрешаются структурой  | Должны быть крайне редки            |
| **Необратимость**         | Не гарантируется                     | Должна быть необратимой             |
| **Стойкость к коллизиям** | Не является критичной                | Критически важна                    |
| **Использование**         | Организация данных                   | Хранение паролей, цифровые подписи  |
