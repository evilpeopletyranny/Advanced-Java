# Ограничения Generics

Java Generics позволяют ограничивать параметры типов с использованием ключевых слов ```extends``` и ```super```, что
позволяет
управлять тем, какие типы данных могут использоваться в обобщенных классах, интерфейсах и методах. Эти ограничения
помогают добиться большей гибкости и безопасности кода, но также накладывают некоторые ограничения на то, как и с какими
типами можно работать.

## 1. Ограничение сверху - extends

- Ограничение сверху (```? extends T```) используется для указания, что параметр типа должен быть либо типом ```T```,
  либо его подклассом.
- Оно поддерживает **ковариантность**, что означает, что можно читать элементы из коллекции или использовать их в
  качестве
  возвращаемых значений, но нельзя безопасно добавлять элементы в коллекцию, так как точный тип неизвестен.

### [Пример](code%2FOverRestrictionMain.java)

Представьте, что у вас есть метод, который работает с числами и их подклассами (например, ```Integer```, ```Double```).
В этом случае можно использовать ```? extends Number```, чтобы указать, что метод принимает любой тип, который является
Number или его подклассом.

```java
import java.util.List;

public class OverRestrictionMain {
    // Метод для суммирования всех элементов списка, который принимает любой тип, наследующий Number
    public static double sumOfList(List<? extends Number> list) {
        double sum = 0.0;
        for (Number num : list) {
            sum += num.doubleValue();
        }
        return sum;
    }

    public static void main(String[] args) {
        List<Integer> intList = List.of(1, 2, 3);
        List<Double> doubleList = List.of(1.1, 2.2, 3.3);

        System.out.println(sumOfList(intList));    // Вывод: 6.0
        System.out.println(sumOfList(doubleList)); // Вывод: 6.6
    }
}
```

### Ограничения и особенности

- Чтение из коллекции безопасно, так как компилятор знает, что объекты будут не ниже уровня ```T``` (
  например, ```Number``` или его подклассы).
- Добавление элементов в коллекцию небезопасно — нельзя точно знать, какой тип безопасно добавить, кроме ```null```.
  Если мы поппытаемся положить в тип не входящий в ограничение, то получим ошибку компиляции, связанную с невозможностью
  преобразовать тип.
- Используется в случаях, когда объект является производителем данных (например, чтение значений).

### Когда использовать

- Когда вам нужно только читать из коллекции или использовать значение, но не изменять коллекцию.
- Для возвращаемых значений, которые должны быть определенного типа или его подкласса.

## 2. Ограничение снизу - super

- Ограничение снизу (```? super T```) указывает, что параметр типа должен быть типом ```T``` или любым его суперклассом.
- Оно поддерживает **контравариантность**, что означает, что можно безопасно добавлять элементы в коллекцию, но чтение
  ограничено типом ```Object```, так как конкретный тип неизвестен.

### [Пример](code%2FBelowRestriction.java)

Представте что у вас есть иерархия классов фигур. Для безопасного добавления только фигур необходим метод, ограниченный
снизу типом интерфейса фигур.
Создадим метод, который внутри себя будет добавлять фигуры в переданный список. Для безопасности в сигнатуре функции
добавим ограничения, что она принимает список ограниченный снизу интерфейсом фигур.

_Пример большой, смотрите его по ссылке._

## Принцип использования: PECS

**PECS** — это акроним, который помогает запомнить, когда использовать ограничения сверху или снизу:

- **Producer Extends**: Если коллекция **производит** данные (вы читаете из нее), используйте ```? extends T```.
- **Consumer Super**: Если коллекция **потребляет** данные (вы добавляете в нее), используйте ```? super T```.

## Работа с классами и интерфейсами

Мы также вправе накладывать ограничения на generic тип класса или интерфейса.

```java
interface Compare<T extends Comparable> {
}
```

```java
// Обобщенный интерфейс с ограничением сверху: T должен быть Entity или его подклассом
interface ComparableEntity<T extends Entity> {
    // Метод для сравнения двух сущностей по их ID
    int compareTo(T other);
}
```