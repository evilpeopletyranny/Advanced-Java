# Сравнение Java Generics и C++ Templates

_Надеюсь, что вы знакомы с ```Templates``` из ```C++```._

```Java Generics``` и ```C++ Templates``` имеют схожую цель — обеспечить возможность создания обобщенных классов и
функций, работающих с различными типами данных. Однако между ними существуют значительные различия в реализации и
поведении.

## 1. Механизм реализации

| ```Java Generics```                                                                                                                                                                                                                                                | ```Templates C++```                                                                                                                                                              |
|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Реализованы через стирание типов (type erasure). Это означает, что информация о типах удаляется на этапе компиляции, и код работает с более общими типами, такими как Object. Например, List<String> и List<Integer> во время выполнения рассматриваются как List. | Шаблоны в C++ реализованы на этапе компиляции, и каждый раз, когда вы используете шаблон с новым типом, компилятор создает новую версию кода для этого типа.                     |
| Все проверки типов выполняются на этапе компиляции, а в байт-коде остаются только общие типы.                                                                                                                                                                      | Это приводит к генерации отдельного машинного кода для каждого типа, что позволяет шаблонам C++ работать с любыми типами, включая примитивные типы и пользовательские структуры. |

## 2. Проверка типов

| ```Java Generics```                                                                                                                                                                                                                                                                                                                                                | ```Templates C++```                                                                                                                                                                                                                                              |
|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Проверки типов выполняются на этапе компиляции. Дженерики не добавляют новой информации о типах в байт-код, и во время выполнения параметры типов стираются. Это значит, что один и тот же код используется для всех параметризованных типов. Например, ```List<String>``` и ```List<Integer>``` во время выполнения рассматриваются как один и тот же ```List```. | В C++ шаблоны проверяются на этапе компиляции только тогда, когда они используются (инстанцируются). Это позволяет C++ обнаруживать ошибки типов, специфичные для используемого типа, но иногда эти ошибки могут быть трудными для понимания из-за их сложности. |
|                                                                                                                                                                                                                                                                                                                                                                    | Генерация кода для каждого типа на этапе компиляции делает шаблоны мощным инструментом для создания оптимизированного кода для каждого конкретного типа.                                                                                                         |

## 3. Поддержка примитивных типов

| ```Java Generics```                                                                                                                                                                                                                                                                 | ```Templates C++```                                                                                                                                                                                        |
|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Дженерики не могут использовать примитивные типы (например, ```int```, ```char```). Вместо этого нужно использовать обертки (```Integer```, ```Character``` и т.д.). Это приводит к дополнительным затратам на автопакетирование и распаковку, что может замедлять выполнение кода. | Шаблоны могут работать с любыми типами, включая примитивные типы, без дополнительных накладных расходов. Это делает шаблоны C++ более производительными, особенно при использовании с примитивными типами. |

## 4. Специализация типов

| ```Java Generics```                                                                                                                                                             | ```Templates C++```                                                                                                                                                                              |
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Дженерики не поддерживают специализацию типов. Код работает одинаково для всех параметризованных типов. Специализация функций или классов на основе параметров типа невозможна. | Шаблоны поддерживают **специализацию типов**, что позволяет создавать отдельные реализации шаблонов для конкретных типов. Это дает гибкость в изменении поведения для определенных типов данных. |

```cpp
C++

// Пример специализации шаблона в C++
template<typename T>
void print(T value) {
    std::cout << value << std::endl;
}

// Специализация для char*
template<>
void print<char*>(char* value) {
    std::cout << "String: " << value << std::endl;
}
```

## 5. Сложность и размер бинарного файла

| ```Java Generics```                                                                                                                                                                     | ```Templates C++```                                                                                                                                                                                              |
|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Поскольку все дженерики стираются до одного общего типа на этапе компиляции, это не увеличивает размер бинарного файла, и время компиляции не зависит от количества используемых типов. | Каждое использование шаблона с новым типом создает новый набор кода, что может значительно увеличить размер бинарного файла и время компиляции, особенно при активном использовании шаблонов с множеством типов. |

## 6. Исключения и обработка типов

| ```Java Generics```                                                                                                                       | ```Templates C++```                                                                                         |
|-------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------|
| Дженерики имеют ограничения при работе с исключениями. Нельзя бросать или ловить исключения параметризованного типа из-за стирания типов. | Шаблоны позволяют ловить и бросать исключения любых типов, что дает больший контроль над обработкой ошибок. |

## 7. Мета-программирование и вычисления на этапе компиляции

| ```Java Generics```                                                                                                                                                                                  | ```Templates C++```                                                                                                                                                                                                                                          |
|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Дженерики в Java не поддерживают метапрограммирование. Они предназначены для типобезопасности и упрощения работы с обобщенными типами, но не могут выполнять сложные вычисления на этапе компиляции. | Шаблоны C++ поддерживают метапрограммирование, что позволяет выполнять сложные вычисления на этапе компиляции и создавать специализированный код. Это позволяет реализовывать паттерны проектирования и алгоритмы, которые выполняются до запуска программы. |

```cpp
C++

// Пример простого метапрограммирования на C++
template<int N>
struct Factorial {
    static const int value = N * Factorial<N - 1>::value;
};

template<>
struct Factorial<0> {
    static const int value = 1;
};

// Вычисляется на этапе компиляции
int result = Factorial<5>::value; // result == 120
```

## Пример: класс Pair реализованный средствами Java Generics и C++ Templates

### Java Generics

```java
// Java: Обобщенный класс Pair
public class Pair<T, U> {
    private T first;   // Первый элемент пары
    private U second;  // Второй элемент пары

    // Конструктор для инициализации пары
    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }

    // Метод для получения первого элемента
    public T getFirst() {
        return first;
    }

    // Метод для установки первого элемента
    public void setFirst(T first) {
        this.first = first;
    }

    // Метод для получения второго элемента
    public U getSecond() {
        return second;
    }

    // Метод для установки второго элемента
    public void setSecond(U second) {
        this.second = second;
    }

    // Переопределение метода toString() для вывода пары
    @Override
    public String toString() {
        return "(" + first + ", " + second + ")";
    }
}
```

### C++ Templates

```cpp
#include <iostream>
using namespace std;

// C++: Обобщенный класс Pair с использованием шаблонов
template <typename T, typename U>
class Pair {
private:
    T first;   // Первый элемент пары
    U second;  // Второй элемент пары

public:
    // Конструктор для инициализации пары
    Pair(T first, U second) : first(first), second(second) {}

    // Метод для получения первого элемента
    T getFirst() const {
        return first;
    }

    // Метод для установки первого элемента
    void setFirst(T first) {
        this->first = first;
    }

    // Метод для получения второго элемента
    U getSecond() const {
        return second;
    }

    // Метод для установки второго элемента
    void setSecond(U second) {
        this->second = second;
    }

    // Метод для вывода пары
    void print() const {
        cout << "(" << first << ", " << second << ")" << endl;
    }
};
```

# Выводы

Java Generics и C++ Templates имеют сходные цели, но их реализации значительно различаются. Дженерики в Java
ориентированы на типобезопасность и удобство использования, обеспечивая проверку типов на этапе компиляции и уменьшение
ошибок времени выполнения. Шаблоны C++ предлагают более мощные возможности для метапрограммирования, позволяют создавать
оптимизированный код для различных типов и дают разработчику больше контроля над поведением программы на этапе
компиляции.

## Задание

